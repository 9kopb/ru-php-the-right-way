---
layout: page
title: Основы
---

# Основы

## Операторы сравнения

Операторы сравнения часто упускается из виду аспект PHP, котоый может привести ко многим неожиданным результатам.
Одна из таких проблем возникает из-за строгого сравнения (сравнение логических значений в виде целых чисел).

{% highlight php %}
<?php
$a = 5;   // 5 как целое число (integer)

var_dump($a == 5);       // Сравниваются значения; Вернёт true
var_dump($a == '5');     // Сравниваются значения (игнорируя типы); Вернёт true
var_dump($a === 5);      // Сравниваются типы и значения (integer vs. integer); Вернёт true
var_dump($a === '5');    // Сравниваются типы и значения (integer vs. string); Вернёт false

/**
 * Строгое сравнение
 */
if (strpos('testing', 'test')) {    // 'test' находится в 0 позиции, результатом будет 'false'
    // Ваш код...
}

vs.

if (strpos('testing', 'test') !== false) {    // Результатом будет 'true', т.к. тут строгое сравнение (0 !== false)
    // Ваш код...
}
{% endhighlight %}

* [Операторы сравнения](http://php.net/manual/ru/language.operators.comparison.php)
* [Таблица сравнения типов](http://php.net/manual/ru/types.comparisons.php)

## Условные операторы

### Оператор "If"

При использовании операторов 'if/else' внутри функции или класса, существует распространнёное заблуждение, что 'else'
должен быть использован при возврате результатов выполнения. Если условие не выполняется и при этом возвращается 
значение (return $value), то использование 'else' может быть спорным.

{% highlight php %}
<?php
function test($a)
{
    if ($a) {
        return true;
    } else {
        return false;
    }
}

vs.

function test($a)
{
    if ($a) {
        return true;
    }
    return false;    // else использовать не обязательно
}
{% endhighlight %}

* [Оператор "If"](http://php.net/manual/ru/control-structures.if.php)

### Оператор "Switch"

Оператор "Switch" является отличным способом, чтобы не использовать много операторов "if" с использованием "elseif",
но необходимо знать некоторые вещи:

- Оператор "Switch" сравнивает только значения, но не типы данных (развнозначно логической операции '==')
- Этот оператор сравнивает выражение с каждым значением, пока не найдёт нужное. Если не нашёл, использвует 
"default" (если определён)
- Без использования 'break', выражение будет сравниваться со всеми значениями по-порядку, пока не встретит "break" 
или "return"
- Если вы используете для возврата результата 'return' то 'break' можно опустить.

{% highlight php %}
<?php
$answer = test(2);    // Этот код выберет 'case 2' и 'case 3'.

function test($a)
{
    switch ($a) {
        case 1:
            // Код...
            break;             // Прекратит выполение switch тут если $a == 1, т.к. используется 'break'
        case 2:
            // Код...         // Код без 'break', поэтому будет выполнено сравнение с 'case 3'
        case 3:
            // Код...
            return $result;    // within a function, 'return' will end the function
        default:
            // Код...
            return $error;
    }
}
{% endhighlight %}

* [Switch statements](http://php.net/manual/en/control-structures.switch.php)
* [PHP switch](http://phpswitch.com/)

## Global namespace

When using namespaces, you may find that internal functions are hidden by functions you wrote. To fix this,
refer to the global function by using a backslash before the function name.

{% highlight php %}
<?php
namespace phptherightway;

function fopen()
{
    $file = \fopen();    // Our function name is the same as an internal function.
                         // Execute the function from the global space by adding '\'.
}

function array()
{
    $iterator = new \ArrayIterator();    // ArrayIterator is an internal class. Using its name without a backslash
                                         // will attempt to resolve it within your namespace.
}
{% endhighlight %}

* [Global space](http://php.net/manual/en/language.namespaces.global.php)
* [Global rules](http://php.net/manual/en/userlandnaming.rules.php)

## Strings

### Concatenation

- If your line extends beyond the recommended line length (120 characters), consider concatenating your line
- For readability it's best to use concatenation operators over concatenating assignment operators
- While within the original scope of the variable, indent when concatenation uses a new line


{% highlight php %}
<?php
$a  = 'Multi-line example';    // concatenating assignment operator (.=)
$a .= "\n";
$a .= 'of what not to do';

vs.

$a = 'Multi-line example'      // concatenation operator (.)
    . "\n"                     // indenting new lines
    . 'of what to do';
{% endhighlight %}

* [String Operators](http://php.net/manual/en/language.operators.string.php)

### String types

String types are a constant feature within the PHP community, but hopefully this section will explain the
differences between the string types and their benefits/uses.

#### Single quotes

Single quotes are the simplest way to define a string and are often the quickest. Their speed stems from PHP not
parsing the string (doesn't parse for variables). They're best suited for:

- Strings that do not need to be parsed
- Writing of a variable into plain text

{% highlight php %}
<?php
echo 'This is my string, look at how pretty it is.';    // no need to parse a simple string

/**
 * Output:
 *
 * This is my string, look at how pretty it is.
 */
{% endhighlight %}

* [Single quote](http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.single)

#### Double quotes

Double quotes are the Swiss army knife of strings, but are slower due to the string being parsed. They're best
suited for:

- Escaped strings
- Strings with multiple variables and plain text
- Condensing multi-line concatenation, and improving readability

{% highlight php %}
<?php
echo 'phptherightway is ' . $adjective . '.'     // a single quotes example that uses multiple concatenating for
    . "\n"                                       // variables and escaped string
    . 'I love learning' . $code . '!';

vs.

echo "phptherightway is $adjective.\n I love learning $code!"  // Instead of multiple concatenating, double quotes
                                                               // enables us to use a parsable string
{% endhighlight %}

While using double quotes that contain variables, it's often the case that the variable will be touching another
character. This will result in PHP not parsing the variable due to the variable being camouflaged. To fix this problem,
wrap the variable within a pair of curly brackets.

{% highlight php %}
<?php
$juice = 'plum';
echo "I drank some juice made of $juices";    // $juice cannot be parsed

vs.

$juice = 'plum';
echo "I drank some juice made of {$juice}s";    // $juice will be parsed

/**
 * Complex variables will also be parsed within curly brackets
 */

$juice = array('apple', 'orange', 'plum');
echo "I drank some juice made of {$juice[1]}s";   // $juice[1] will be parsed
{% endhighlight %}

* [Double quotes](http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.double)

#### Nowdoc syntax

Nowdoc syntax was introduced in 5.3 and internally behaves the same way as single quotes except it's suited toward the
use of multi-line strings without the need for concatenating.

{% highlight php %}
<?php
$str = <<<'EOD'             // initialized by <<<
Example of string
spanning multiple lines
using nowdoc syntax.
$a does not parse.
EOD;                        // closing 'EOD' must be on it's own line, and to the left most point

/**
 * Output:
 *
 * Example of string
 * spanning multiple lines
 * using nowdoc syntax.
 * $a does not parse.
 */
{% endhighlight %}

* [Nowdoc syntax](http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.nowdoc)

#### Heredoc syntax

Heredoc syntax internally behaves the same way as double quotes except it's suited toward the use of multi-line
strings without the need for concatenating.

{% highlight php %}
<?php
$a = 'Variables';

$str = <<<EOD               // initialized by <<<
Example of string
spanning multiple lines
using heredoc syntax.
$a are parsed.
EOD;                        // closing 'EOD' must be on it's own line, and to the left most point

/**
 * Output:
 *
 * Example of string
 * spanning multiple lines
 * using heredoc syntax.
 * Variables are parsed.
 */
{% endhighlight %}

* [Heredoc syntax](http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.heredoc)

## Ternary operators

Ternary operators are a great way to condense code, but are often used in excess. While ternary operators can be
stacked/nested, it is advised to use one per line for readability.

{% highlight php %}
<?php
$a = 5;
echo ($a == 5) ? 'yay' : 'nay';

vs.

// nested ternary
$b = 10;
echo ($a) ? ($a == 5) ? 'yay' : 'nay' : ($b == 10) ? 'excessive' : ':(';    // excess nesting, sacrificing readability
{% endhighlight %}

To 'return' a value with ternary operators use the correct syntax.

{% highlight php %}
<?php
$a = 5;
echo ($a == 5) ? return true : return false;    // this example will output an error

vs.

$a = 5;
return ($a == 5) ? 'yay' : 'nope';    // this example will return 'yay'
{% endhighlight %}

* [Ternary operators](http://php.net/manual/en/language.operators.comparison.php)

## Variable declarations

At times, coders attempt to make their code "cleaner" by declaring predefined variables with a different name. What
this does in reality is to double the memory consumption of said script. For the example below, let's say
an example string of text contains 1MB worth of data, by copying the variable you've increased the scripts execution to
2MB.

{% highlight php %}
<?php
$about = 'A very long string of text';    // uses 2MB memory
echo $about;

vs.

echo 'A very long string of text';        // uses 1MB memory
{% endhighlight %}

* [Performance tips](https://developers.google.com/speed/articles/optimizing-php)
